<?php

class M {
	public function identify() {
		echo self::myName();
	}
	public function myName() {
		return "Mike";
	}
}

class N extends M {
	public function myName() {
		return "November";
	}
}

function m(N $n) {
	$n->identify();
}

$m = new N();

m($m);

// Output: Mike

// NOTE: Late static binding http://php.net/manual/en/language.oop5.late-static-bindings.php What happens is that we instantiate an N confusingly stored in $m, and then call m() on it which, after passing the typehint successfully, calls the identify() method in the N class. This is inherited from M, but PHP will use M where we put "self" nstead of using N. Late static binding means we could use "static" instead of "self" and get "November" as the output.
